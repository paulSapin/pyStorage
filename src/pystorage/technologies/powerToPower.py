from __future__ import annotationsimport warningsimport numpy as npfrom scipy.interpolate import LinearNDInterpolatorfrom abc import ABC, abstractmethodfrom collections.abc import Iterablefrom ..data import CEPCI, PNNL_CAES, currencyIndexfrom ..config import getTheScene""" ABSTRACT CLASS """class _AbstractElectricityStorageTechnology(ABC):    @abstractmethod    def __init__(self):        # Get the scene        scene = getTheScene()        Country = scene['Country']        Year = int(scene['Year'])        Currency = scene['Currency']        # Location and time-specific data        self._year: int = Year if isinstance(Year, int) else None        self._country: str = Country if isinstance(Country, str) else None        self._currency: str = Currency if isinstance(Currency, str) else None        # Battery type        self._type: str | None = None  # PHES / LAES / (A-D-I-)CAES / PTES / Flow / LiIon / Flywheel        # Battery technical characteristics (size)        self._dischargeDuration: float | None = None  # Discharge duration [s]        self._dischargingPower: float | None = None  # Discharging rate/power [W]        self._chargeDuration: float | None = None  # Charge duration [s]        self._chargingPower: float | None = None  # Charging rate/power [W]        # Battery technical performance        self._nominalRoundtripEfficiency: float | None = None  # Electricity-to-electricity roundtrip efficiency        self._selfDischargeRate: float | None = None  # Self-discharge rate [0 - 1]        # Secondary fuel / energy vector        self._secSource: str | None = None  # Secondary energy source             (e.g., gas, H2)        self._secConsumptionRatio: float | None = None  # Consumption ratio upon discharge [kWh_g / kWh_e]        # Battery economic value        self._powerIslandSpecificCost: float | list[float] | None = None  # [$/kW]        self._storeSpecificCost: float | list[float] | None = None  # [$/kWh]        # Economic conditions (scenario-, year- & country-dependent parameters)        self._electricityPrice: float | None = None  # (Mean) electricity price [$/MWh]        self._gasPrice: float | None = None  # (Mean) gas price [$/MWh]        self._hydrogenPrice: float | None = None  # (Mean) hydrogen price [$/MWh]        self._discountRate: float | None = None  # Discount rate [0 - 1]        # Utilisation / operational parameters        self._lifetime: int | None = None  # System lifetime [years]        self._frequency: int | None = None  # Number of cycles / year [1 - maxFreq]        self._standby: float | None = None  # Non-dimensional standby duration [0 - 1]        # Scene-dependent ghost properties        self.__wholesaleElectricityPrice: list[float] | None = None  # Time-resolved electricity tariff [$/MWh]        self.__wholesaleGasPrice: list[float] | None = None  # Time-resolved gas tariff [$/MWh]        self.__CEPCI: float | None = None  # Chemical Engineering Plant Cost Index (CEPCI)        # Ghost dependent properties        self.__workingCycleDuration: float | None = None        self.__wholeCycleDuration: float | None = None        self.__standbyDuration: float | None = None        self.__maximumFrequency: float | None = None        self.__investmentCost: float | list[float] | None = None        self.__storageCapacity: float | None = None        self.__LCOS: float | list[float] | None = None        self.__inputElectricity: float | None = None        self.__outputElectricity: float | None = None        self.__roundtripEfficiency: float | None = None    """ Factory & reset methods """    @abstractmethod    def factory(self) -> _AbstractElectricityStorageTechnology:        raise NotImplementedError  # pragma: no cover    def resetGhostProperties(self):        self.__workingCycleDuration = None        self.__wholeCycleDuration = None        self.__standbyDuration = None        self.__maximumFrequency = None        self.__investmentCost = None        self.__storageCapacity = None        self.__LCOS = None        self.__inputElectricity = None        self.__outputElectricity = None        self.__roundtripEfficiency = None    """ Assign static & dynamic methods """    @staticmethod    def _assign(obj, *,                dischargeDuration: float | None = None,  # nominal discharge duration [s]                dischargingPower: float | None = None,  # nominal discharging power [W]                chargeDuration: float | None = None,  # nominal charge duration [s]                chargingPower: float | None = None,  # nominal charging power [W]                roundtripEfficiency: float | None = None,  # (x > 0)                powerIslandSpecificCost: float | None = None,  # [$/kW]                storeSpecificCost: float | None = None,  # [$/kWh]                selfDischargeRate: float | None = None,  # [%/h]                secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                secondaryConsumptionRatio: float | None = None,  # gas consumption ratio upon discharge [kWh_g / kWh_e]                electricityPrice: float | None = None,  # [$/MWh]                gasPrice: float | None = None,  # [$/MWh]                hydrogenPrice: float | None = None,  # [$/MWh]                frequency: float | None = None,  # number of cycles per year [#/year]                lifetime: int | None = None,                discountRate: float | None = None,                standby: float | None = None                ):        # Check validity of dischargeDuration and assign if correct        if dischargeDuration is not None:            if dischargeDuration >= 0:                obj._dischargeDuration = dischargeDuration            else:                raise ValueError('dischargeDuration must be positive.')        # Check validity of chargeDuration and assign if correct        if chargeDuration is not None:            if chargeDuration >= 0:                obj._chargeDuration = chargeDuration            else:                raise ValueError('chargeDuration must be positive.')        # Check validity of dischargingPower and assign if correct        if dischargingPower is not None:            if dischargingPower >= 0:                obj._dischargingPower = dischargingPower            else:                raise ValueError('dischargingPower must be positive.')        # Check validity of chargingPower and assign if correct        if chargingPower is not None:            if chargingPower >= 0:                obj._chargingPower = chargingPower            else:                raise ValueError('chargingPower must be positive.')        # Check validity of round-trip efficiency and assign if correct        if roundtripEfficiency is not None:            if 0 <= roundtripEfficiency:                obj._nominalRoundtripEfficiency = roundtripEfficiency            else:                raise ValueError('Electricity-to-electricity roundtrip efficiency must be greater than 0.')        # Check / enforce validity of energy input / output        W_in = obj.nominalChargingPower_MW        dt_in = obj.nominalChargeDuration_hours        W_out = obj.nominalDischargingPower_MW        dt_out = obj.nominalDischargeDuration_hours        eta = obj.nominalRoundTripEfficiency        parameters = [W_in, dt_in, W_out, dt_out, eta]        if None not in parameters:            if not np.isclose((W_out * dt_out) / (W_in * dt_in), eta):                raise ValueError("Inconsistent charge/discharge and efficiency values.")        elif parameters.count(None) == 1:            if dt_in is None:                obj._chargeDuration = W_out * dt_out / (eta * W_in) * 3600            elif W_in is None:                obj._chargingPower = W_out * dt_out / (eta * dt_in) / 1e6            elif eta is None:                obj._nominalRoundtripEfficiency = (W_out * dt_out) / (W_in * dt_in)            elif dt_out is None:                obj._dischargeDuration = eta * W_in * dt_in / W_out * 3600            elif W_out is None:                obj._dischargingPower = eta * W_in * dt_in / dt_out / 1e6        # Check validity of powerIslandSpecificCost_per_kW and assign if correct        if powerIslandSpecificCost is not None:            if powerIslandSpecificCost >= 0:                obj._powerIslandSpecificCost = powerIslandSpecificCost            else:                raise ValueError('powerIslandSpecificCost_per_kW must be positive.')        # Check validity of storeSpecificCost_per_kWh and assign if correct        if storeSpecificCost is not None:            if storeSpecificCost >= 0:                obj._storeSpecificCost = storeSpecificCost            else:                raise ValueError('storeSpecificCost_per_kWh must be positive.')        # Check validity of electricityPrice and assign if correct        if electricityPrice is not None:            if electricityPrice >= 0:                obj._electricityPrice = electricityPrice            else:                raise ValueError('electricityPrice must be positive.')        # Check validity of gasPrice and assign if correct        if gasPrice is not None:            if gasPrice >= 0:                obj._gasPrice = gasPrice            else:                raise ValueError('gasPrice must be positive.')        # Check validity of hydrogenPrice and assign if correct        if hydrogenPrice is not None:            if hydrogenPrice >= 0:                obj._hydrogenPrice = hydrogenPrice            else:                raise ValueError('hydrogenPrice must be positive.')        # Check validity of secondaryConsumptionRatio and assign if correct        if secondaryConsumptionRatio is not None:            if secondaryConsumptionRatio >= 0:                obj._secConsumptionRatio = secondaryConsumptionRatio            else:                raise ValueError('secondaryConsumptionRatio must be positive.')        # Check validity of self-discharge rate and assign if correct        if selfDischargeRate is not None:            if 0 <= selfDischargeRate <= 1:                obj._selfDischargeRate = selfDischargeRate            else:                raise ValueError('Self-discharge rate must lie between 0 and 1')        # Check validity of the secondary source and assign if correct        if secondarySource is not None:            if secondarySource in ['electricity', 'gas', 'hydrogen']:                obj._secSource = secondarySource            else:                raise ValueError('Secondary fuel must be either electricity, gas or hydrogen.')        # Check validity of frequency and assign if correct        if frequency is not None:            if frequency >= 0:                obj._frequency = frequency            else:                raise ValueError('Frequency must be greater than 1.')        # Check validity of lifetime and assign if correct        if lifetime is not None:            if lifetime >= 1:                obj._lifetime = lifetime            else:                raise ValueError('Lifetime must be an integer greater than 1.')        # Check validity of discount rate and assign if correct        if discountRate is not None:            if 0 <= discountRate <= 1:                obj._discountRate = discountRate            else:                raise ValueError('Discount rate must lie between 0 and 1')        # Check validity of non-dimensional standby duration and assign if correct        if standby is not None:            if 0 <= standby <= 1:                obj._standby = standby            else:                raise ValueError('standby rate must lie between 0 and 1')        return obj    def updateOperatingConditions(self,                                  frequency: float | None = None,  # number of cycles per year [#/year]                                  standby: float | None = None                                  ):        self.resetGhostProperties()        self._assign(obj=self,                     frequency=frequency,                     standby=standby)    def updateDiscountRate(self, discountRate: float):        if 0 <= discountRate <= 1:            self._discountRate = discountRate        else:            raise ValueError('Discount rate must lie between 0 and 1.')    def updateEnergyPrices(self, currency: str, *,                           electricity: float | None = None,                           gas: float | None = None,                           hydrogen: float | None = None):        self.resetGhostProperties()        # Conversion factor        dataCurrencyIndex = currencyIndex(currency)        k = self.__currencyIndex__() / dataCurrencyIndex        if electricity is not None:            if electricity >= 0:                self._electricityPrice = electricity * k            else:                raise ValueError('Electricity price must be positive.')        if gas is not None:            if gas >= 0:                self._gasPrice = gas * k            else:                raise ValueError('Gas price must be positive.')        if hydrogen is not None:            if hydrogen >= 0:                self._hydrogenPrice = hydrogen * k            else:                raise ValueError('Hydrogen price must be positive.')    """ Location and time-specific data """    @property    def year(self) -> int:        return self._year    @property    def country(self) -> str:        return self._country    @property    def currency(self) -> str:        return self._currency    def __currencyIndex__(self) -> float | None:        return currencyIndex(self.currency)    """ System designation """    @property    def type(self):        return self._type    """ Battery technical characteristics (size) """    @property    def nominalDischargeDuration_hours(self):        if self._dischargeDuration is None:            return None        else:            return self._dischargeDuration / 3600    @property    def nominalChargeDuration_hours(self):        if self._chargeDuration is None:            return None        else:            return self._chargeDuration / 3600    @property    def nominalDischargingPower_MW(self):        if self._dischargingPower is None:            return None        else:            return self._dischargingPower / 1e6    @property    def nominalChargingPower_MW(self):        if self._chargingPower is None:            return None        else:            return self._chargingPower / 1e6    """ Technical performance """    @property    def nominalRoundTripEfficiency(self):        return self._nominalRoundtripEfficiency    @property    def selfDischargeRate_percentPerHour(self):        return self._selfDischargeRate    @property    def secondarySource(self) -> list:        if self._secSource is None:            return []        else:            return [self._secSource]    """ Secondary fuel / energy vector """    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        return self._secConsumptionRatio    @property    def secondarySourceInput_MWh(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if not self.secondarySourceConsumptionRatio:            return 0.        else:            r = self.secondarySourceConsumptionRatio            W_out = self.outputElectricity_MWh            if None not in [W_out, r]:                return W_out * r            else:                return None    """ Economic value """    @property    def powerIslandSpecificCost_per_kW(self) -> float | None:        return self._powerIslandSpecificCost    @property    def storeSpecificCost_per_kWh(self) -> float | None:        return self._storeSpecificCost    """ Economic conditions (scenario- & country-dependent parameters) """    @property    def electricityPrice(self) -> float | None:        return self._electricityPrice    @property    def gasPrice(self) -> float | None:        return self._gasPrice    @property    def hydrogenPrice(self) -> float | None:        return self._hydrogenPrice    @property    def discountRate(self) -> float | None:        return self._discountRate    @property    def wholesaleElectricityPrice(self) -> float | None:        if self.__wholesaleElectricityPrice is None:            if self.year in CEPCI.index:                self.__wholesaleElectricityPrice = CEPCI[self.year]            else:                warnings.warn(f'The CEPCI is not available for {self.year}.')        return self.__wholesaleElectricityPrice    @property    def CEPCI(self) -> float | None:        if self.__CEPCI is None:            if self.year in CEPCI.index:                self.__CEPCI = CEPCI[self.year]            else:                warnings.warn(f'The CEPCI is not available for {self.year}.')        return self.__CEPCI    """ Utilisation / operational parameters """    @property    def lifetime(self) -> int | None:        return self._lifetime    @property    def frequency(self) -> float | None:        if self._frequency is not None:            return self.maximumFrequency if self._frequency > self.maximumFrequency else self._frequency        else:            return None    """ Dependent properties """    @property    def wholeCycleDuration_hours(self) -> float | None:        if self.__wholeCycleDuration is None:            f = self.frequency            if f is not None:                self.__wholeCycleDuration = 8760 / f        return self.__wholeCycleDuration    @property    def standbyDuration_hours(self) -> float | None:        if self.__standbyDuration is None:            dt = self.wholeCycleDuration_hours            dt_w = self.workingCycleDuration_hours            dt_norm_stb = self._standby            if None not in [dt, dt_w, dt_norm_stb]:                dt_idle = dt - dt_w                self.__standbyDuration = dt_norm_stb * dt_idle        return self.__standbyDuration    @property    def workingCycleDuration_hours(self) -> float | None:        if self.__workingCycleDuration is None:            dt_discharge = self.nominalDischargeDuration_hours  # [s]            dt_charge = self.nominalChargeDuration_hours  # [h]            if None not in [dt_discharge, dt_charge]:                self.__workingCycleDuration = (dt_discharge + dt_charge)        return self.__workingCycleDuration    @property    def storageCapacity_MWh(self) -> float | None:        if self.__storageCapacity is None:            # Gather inputs parameters            dt = self._dischargeDuration  # [s]            W = self._dischargingPower  # [W]            if None not in [W, dt]:                self.__storageCapacity = W * dt / 3600 / 1e6        return self.__storageCapacity    @property    def investmentCost(self) -> float | None:        if self.__investmentCost is None:            # Gather inputs parameters            cost_per_kW = self.powerIslandSpecificCost_per_kW  # [$/kW]            cost_per_kWh = self.storeSpecificCost_per_kWh  # [$/kWh]            MW = self.nominalDischargingPower_MW            MWh = self.storageCapacity_MWh            if None not in [MW, MWh, cost_per_kWh, cost_per_kW]:                self.__investmentCost = MW * cost_per_kW * 1e3 + MWh * cost_per_kWh * 1e3        return self.__investmentCost    @property    def maximumFrequency(self) -> int | None:        if self.__maximumFrequency is None:            # Gather inputs parameters            cycleDuration = self.workingCycleDuration_hours            if cycleDuration is not None:                self.__maximumFrequency = int(8760 / cycleDuration)        return self.__maximumFrequency    @property    def inputElectricity_MWh(self) -> float | None:        if self.__inputElectricity is None:            # Gather inputs parameters            MW = self.nominalChargingPower_MW            hours = self.nominalChargeDuration_hours            if None not in [MW, hours]:                self.__inputElectricity = MW * hours        return self.__inputElectricity    @property    def outputElectricity_MWh(self) -> float | None:        if self.__outputElectricity is None:            # Gather inputs parameters            W_in = self.inputElectricity_MWh            dWdt = self.selfDischargeRate_percentPerHour / 100            dt_stb = self.standbyDuration_hours            eta = self.nominalRoundTripEfficiency            if None not in [W_in, dWdt, dt_stb, eta]:                W_st = W_in * (1 - dWdt) ** dt_stb                self.__outputElectricity = eta * W_st if W_st > 0 else 0        return self.__outputElectricity    @property    def roundtripEfficiency(self):        if self.__roundtripEfficiency is None:            W_in = self.inputElectricity_MWh            W_out = self.outputElectricity_MWh            if None not in [W_in, W_out]:                self.__roundtripEfficiency = W_out / W_in        return self.__roundtripEfficiency    @property    def levelisedCostOfStorage(self) -> float | list[float] | None:        if self.__LCOS is None:            # Gather inputs parameters            investmentCost = self.investmentCost            W_in_MWh = self.inputElectricity_MWh            W_out_MWh = self.outputElectricity_MWh            i = self.discountRate            n = self.lifetime            f = self.frequency            C_el = self.electricityPrice  # $/MWh            Q_sec_Mwh = self.secondarySourceInput_MWh            C_sec = 0 if not self.secondarySource \                else self.gasPrice if self.secondarySource[0] == 'gas' \                else self.hydrogenPrice if self.secondarySource[0] == 'hydrogen' \                else None            if None not in [investmentCost, i, n, W_in_MWh, W_out_MWh, f, Q_sec_Mwh, C_sec]:                n = np.arange(1, n)                discount = (1 + i) ** n                # Upfront costs                C_inv = investmentCost                # Discounted operational costs                yearlyConsumption = W_in_MWh * C_el * f + Q_sec_Mwh * C_sec * f                C_op = (yearlyConsumption / discount).sum()                # Discounted electricity recovered                yearlyDischarge = W_out_MWh * f                W_kWh = (yearlyDischarge / discount).sum()                self.__LCOS = (C_inv + C_op) / W_kWh  # [$/kWh]                if isinstance(self.__LCOS, Iterable):                    self.__LCOS = [float(x) for x in self.__LCOS]        return self.__LCOS""" SYSTEMS """class ElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()    def factory(self) -> ElectricityStorageTechnology:        return ElectricityStorageTechnology()    def withInputs(self, *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   dischargingPower: float | None = None,  # nominal discharging power [W]                   chargeDuration: float | None = None,  # nominal charge duration [s]                   chargingPower: float | None = None,  # nominal charging power [W]                   roundtripEfficiency: float | None = None,  # (instantaneous) roundtrip efficiency (x > 0)                   powerIslandSpecificCost: float | None = None,  # power-specific cost of the power island [$/kW]                   storeSpecificCost: float | None = None,  # energy-specific cost of the store [$/kWh]                   selfDischargeRate: float = 0,  # self-discharge rate [%/h]                   secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                   secondaryConsumptionRatio: float | None = 0,  # gas consumption ratio upon discharge [kWh_g / kWh_e]                   discountRate: float | None = None,                   frequency: float | None = None,                   lifetime: int | None = None,                   standby: float | None = 1.) -> ElectricityStorageTechnology:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            roundtripEfficiency=roundtripEfficiency,            powerIslandSpecificCost=powerIslandSpecificCost,            storeSpecificCost=storeSpecificCost,            selfDischargeRate=selfDischargeRate,            secondarySource=secondarySource,            secondaryConsumptionRatio=secondaryConsumptionRatio,            frequency=frequency,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return objclass DataDrivenElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    """ Data stored in pystorage/data folder as csv files with the following columns:    duration, power,    roundtripEfficiency, secondaryConsumptionRatio,    powerIslandSpecificCost_LB, powerIslandSpecificCost, powerIslandSpecificCost_UB,    storeSpecificCost_LB, storeSpecificCost, storeSpecificCost_UB    """    def __init__(self):        super().__init__()        # Collected data        self._data = None        self._type: str | None = None        self._model: str | None = None        # Scattered interpolation for technical performance        self._roundtripEfficiency_int: LinearNDInterpolator | None = None  # e-to-e ratio [W_out / W_in]        self._secConsumptionRatio_int: LinearNDInterpolator | None = None  # consumption ratio [kWh_g / kWh_e]        # Scattered interpolation for power island SIC        self._powerIslandSIC_int: LinearNDInterpolator | None = None        self._powerIslandSIC_LB_int: LinearNDInterpolator | None = None        self._powerIslandSIC_UB_int: LinearNDInterpolator | None = None        # Scattered interpolation for store SIC        self._storeSIC_int: LinearNDInterpolator | None = None        self._storeSIC_LB_int: LinearNDInterpolator | None = None        self._storeSIC_UB_int: LinearNDInterpolator | None = None        # Re-define ghost investment cost        self.__investmentCost: list[float] | None = None    """ Factory & reset methods """    def factory(self) -> DataDrivenElectricityStorageTechnology:        return DataDrivenElectricityStorageTechnology()    def resetGhostProperties(self):        super().resetGhostProperties()        # Design-dependent hidden properties        self._nominalRoundtripEfficiency = None        self._secConsumptionRatio = None        self._powerIslandSpecificCost = None        self._storeSpecificCost = None        # Additional ghost properties        self.__investmentCost = None    """ Assign static & dynamic methods """    @staticmethod    def _assignData(obj, data, currency):        # Store data        obj._data = data        # Conversion factor        dataCurrencyIndex = currencyIndex(currency)        k = obj.__currencyIndex__() / dataCurrencyIndex        # Extract data        duration = data.duration.values        power = data.power.values        roundtripEfficiency = data.roundtripEfficiency.values        secondaryConsumptionRatio = data.secondaryConsumptionRatio.values        powerIslandSpecificCost = data.powerIslandSpecificCost.values * k        powerIslandSpecificCost_LB = data.powerIslandSpecificCost_LB.values * k        powerIslandSpecificCost_UB = data.powerIslandSpecificCost_UB.values * k        storeSpecificCost = data.storeSpecificCost.values * k        storeSpecificCost_LB = data.storeSpecificCost_LB.values * k        storeSpecificCost_UB = data.storeSpecificCost_UB.values * k        # Scattered interpolation for technical performance        obj._roundtripEfficiency_int = LinearNDInterpolator(list(zip(duration, power)), roundtripEfficiency)        obj._secConsumptionRatio_int = LinearNDInterpolator(list(zip(duration, power)), secondaryConsumptionRatio)        # Scattered interpolation for power island SIC        obj._powerIslandSIC_int = LinearNDInterpolator(list(zip(duration, power)), powerIslandSpecificCost)        obj._powerIslandSIC_LB_int = LinearNDInterpolator(list(zip(duration, power)), powerIslandSpecificCost_LB)        obj._powerIslandSIC_UB_int = LinearNDInterpolator(list(zip(duration, power)), powerIslandSpecificCost_UB)        # Scattered interpolation for store SIC        obj._storeSIC_int = LinearNDInterpolator(list(zip(duration, power)), storeSpecificCost)        obj._storeSIC_LB_int = LinearNDInterpolator(list(zip(duration, power)), storeSpecificCost_LB)        obj._storeSIC_UB_int = LinearNDInterpolator(list(zip(duration, power)), storeSpecificCost_UB)        return obj    def withInputs(self, dataSource: str,                   *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   dischargingPower: float | None = None,  # nominal discharging power [W]                   chargeDuration: float | None = None,  # nominal charge duration [s]                   chargingPower: float | None = None,  # nominal charging power [W]                   selfDischargeRate: float = 0,  # self-discharge rate [%/h]                   discountRate: float | None = None,                   frequency: float | None = None,                   lifetime: int | None = None,                   standby: float | None = 1.) -> DataDrivenElectricityStorageTechnology:        obj = self.factory()        if dataSource == 'PNNL_CAES':            obj._type = 'D-CAES'            obj._model = 'PNNL'            obj._secSource = 'gas'            obj._assignData(obj, data=PNNL_CAES, currency='USD')        else:            raise ValueError(f'No data available for {dataSource}')        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            selfDischargeRate=selfDischargeRate,            frequency=frequency,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return obj    def updateDataSource(self, dataSource: str):        if dataSource == 'PNNL_CAES':            self._type = 'D-CAES'            self._model = 'PNNL'            self._secSource = 'gas'            self._assignData(self, data=PNNL_CAES, currency='USD')        else:            raise ValueError(f'No data available for {dataSource}')    def updateDesign(self, *,                     dischargeDuration: float | None = None,  # nominal discharge duration [s]                     dischargingPower: float | None = None,  # nominal discharging power [W]                     chargeDuration: float | None = None,  # nominal charge duration [s]                     chargingPower: float | None = None,  # nominal charging power [W]                     selfDischargeRate: float = 0,  # self-discharge rate [%/h]                     lifetime: int | None = None                     ):        # Reset ghost properties        self.resetGhostProperties()        self._assign(obj=self,                     dischargeDuration=dischargeDuration,                     dischargingPower=dischargingPower,                     chargeDuration=chargeDuration,                     chargingPower=chargingPower,                     selfDischargeRate=selfDischargeRate,                     lifetime=lifetime)    """ Dependent properties """    @property    def model(self) -> str:        return self._model    @property    def nominalRoundTripEfficiency(self) -> float | None:        if self._nominalRoundtripEfficiency is None:            hours = self.nominalDischargeDuration_hours            MW = self.nominalDischargingPower_MW            if None not in [hours, MW]:                self._nominalRoundtripEfficiency = float(self._roundtripEfficiency_int(hours, MW))        return self._nominalRoundtripEfficiency    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if self._secConsumptionRatio is None:            hours = self.nominalDischargeDuration_hours            MW = self.nominalDischargingPower_MW            if None not in [hours, MW]:                self._secConsumptionRatio = float(self._secConsumptionRatio_int(hours, MW))        return self._secConsumptionRatio    @property    def powerIslandSpecificCost_per_kW(self) -> list[float] | None:        if self._powerIslandSpecificCost is None:            baseCEPCI = CEPCI[2023]            currentCEPCI = self.CEPCI            hours = self.nominalDischargeDuration_hours            MW = self.nominalDischargingPower_MW            if None not in [hours, MW, currentCEPCI]:                # Specific cost interpolation                cost = self._powerIslandSIC_int(hours, MW)                lowCost = self._powerIslandSIC_LB_int(hours, MW)                highCost = self._powerIslandSIC_UB_int(hours, MW)                # Inflation                cost = cost * (currentCEPCI / baseCEPCI)                lowCost = lowCost * (currentCEPCI / baseCEPCI)                highCost = highCost * (currentCEPCI / baseCEPCI)                self._powerIslandSpecificCost = [float(lowCost), float(cost), float(highCost)]        return self._powerIslandSpecificCost    @property    def storeSpecificCost_per_kWh(self) -> list[float] | None:        if self._storeSpecificCost is None:            baseCEPCI = CEPCI[2023]            currentCEPCI = self.CEPCI            hours = self.nominalDischargeDuration_hours            MW = self.nominalDischargingPower_MW            if None not in [hours, MW, currentCEPCI]:                # Specific cost interpolation                cost = self._storeSIC_int(hours, MW)                lowCost = self._storeSIC_LB_int(hours, MW)                highCost = self._storeSIC_UB_int(hours, MW)                # Inflation                cost = cost * (currentCEPCI / baseCEPCI)                lowCost = lowCost * (currentCEPCI / baseCEPCI)                highCost = highCost * (currentCEPCI / baseCEPCI)                self._storeSpecificCost = [float(lowCost), float(cost), float(highCost)]        return self._storeSpecificCost    @property    def investmentCost(self) -> list[float] | None:        if self.__investmentCost is None and self.powerIslandSpecificCost_per_kW is not None:            self.__investmentCost = []            for n in np.arange(len(self.powerIslandSpecificCost_per_kW)):                # Gather inputs parameters                cost_per_kW = self.powerIslandSpecificCost_per_kW[n]  # [$/kW]                cost_per_kWh = self.storeSpecificCost_per_kWh[n]  # [$/kWh]                MW = self.nominalDischargingPower_MW                MWh = self.storageCapacity_MWh                if None not in [MW, MWh, cost_per_kWh, cost_per_kW]:                    kWh = MWh * 1e3                    kW = MW * 1e3                    self.__investmentCost.append(float(kW * cost_per_kW + kWh * cost_per_kWh))        return self.__investmentCostclass DiabaticCAES(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()        self._type = 'D-CAES'        self._model = 'firstLaw'    def factory(self) -> DiabaticCAES:        return DiabaticCAES()    def withDesign(self, *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   power: float | None = None,  # nominal discharging power [W]                   selfDischargeRate: float = 0  # self-discharge rate [%/h]                   ) -> DiabaticCAES:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=power,            chargingPower=power,            selfDischargeRate=selfDischargeRate,            roundtripEfficiency=self._nominalRoundtripEfficiency,            secondarySource=self._secSource,            secondaryConsumptionRatio=self._secConsumptionRatio)        return obj    @property    def model(self) -> str:        return self._model