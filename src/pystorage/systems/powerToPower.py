from __future__ import annotationsimport warningsimport numpy as npfrom scipy.interpolate import LinearNDInterpolatorfrom abc import ABC, abstractmethodfrom collections.abc import Iterablefrom ..data import CEPCI, PNNL_CAES, currencyIndexfrom ..config import getTheScene, getUnits, uregQ_ = ureg.Quantity""" ABSTRACT CLASS """class _AbstractElectricityStorageTechnology(ABC):    @abstractmethod    def __init__(self):        # Get the scene        scene = getTheScene()        self._country = scene['Country']        self._year = int(scene['Year'])        # Get currency        self._units = getUnits()        self._currency = self._units['currency']        # Battery type        self._type: str | None = None  # PHES / LAES / (A-D-I-)CAES / PTES / Flow / LiIon / Flywheel        # Battery technical characteristics (size)        self._dischargeDuration: ureg.Quantity | None = None  # Discharge duration [s]        self._dischargingPower: ureg.Quantity | None = None  # Discharging rate/power [W]        self._chargeDuration: ureg.Quantity | None = None  # Charge duration [s]        self._chargingPower: ureg.Quantity | None = None  # Charging rate/power [W]        # Battery technical performance        self._nominalRoundtripEfficiency: ureg.Quantity | None = None  # Electricity-to-electricity roundtrip efficiency        self._selfDischargeRate: ureg.Quantity | None = None  # Self-discharge rate [0 - 1]        # Secondary fuel / energy vector        self._secSource: str | None = None  # Secondary energy source             (e.g., gas, H2)        self._secConsumptionRatio: float | None = None  # Consumption ratio upon discharge [kWh_g / kWh_e]        # Battery economic value (scene-dependent as depend on CEPCI)        self._powerIslandSpecificCost: ureg.Quantity | None = None  # [$/kW]        self._storeSpecificCost: ureg.Quantity | None = None  # [$/kWh]        # Economic conditions (scenario-, year- & country-dependent parameters)        self._electricityPrice: ureg.Quantity | None = None  # (Mean) electricity price [$/MWh]        self._gasPrice: ureg.Quantity | None = None  # (Mean) gas price [$/MWh]        self._hydrogenPrice: ureg.Quantity | None = None  # (Mean) hydrogen price [$/MWh]        self._discountRate: ureg.Quantity | None = None  # Discount rate [0-1]        # Utilisation / operational parameters        self._lifetime: ureg.Quantity | None = None  # System lifetime [years]        self._frequency: ureg.Quantity | None = None  # Number of cycles / year [1 - maxFreq]        self._standby: float | None = None  # Non-dimensional standby duration [0 - 1]        # Scene-dependent ghost properties        self.__wholesaleElectricityPrice__: ureg.Quantity | None = None  # Time-resolved electricity tariff [$/MWh]        self.__wholesaleGasPrice__: ureg.Quantity | None = None  # Time-resolved gas tariff [$/MWh]        self.__investmentCost__: ureg.Quantity | None = None        self.__CEPCI__: ureg.Quantity | None = None  # Chemical Engineering Plant Cost Index (CEPCI)        self.__LCOS__: ureg.Quantity | None = None        # Technical ghost dependent properties        self.__workingCycleDuration__: ureg.Quantity | None = None        self.__wholeCycleDuration__: ureg.Quantity | None = None        self.__standbyDuration__: ureg.Quantity | None = None        self.__maximumFrequency__: ureg.Quantityloat | None = None        self.__storageCapacity__: ureg.Quantity | None = None        self.__inputElectricity__: ureg.Quantity | None = None        self.__outputElectricity__: ureg.Quantity | None = None        self.__roundtripEfficiency__: ureg.Quantity | None = None    """ Factory & reset methods """    @abstractmethod    def factory(self) -> _AbstractElectricityStorageTechnology:        raise NotImplementedError  # pragma: no cover    def _resetSceneDependentGhostProperties(self):        # Scene-dependent ghost properties        self.__wholesaleElectricityPrice__ = None        self.__wholesaleGasPrice__ = None        self.__investmentCost__ = None        self.__CEPCI__ = None        self.__LCOS__ = None    def _resetGhostProperties(self):        self.__workingCycleDuration__ = None        self.__wholeCycleDuration__ = None        self.__standbyDuration__ = None        self.__maximumFrequency__ = None        self.__investmentCost__ = None        self.__storageCapacity__ = None        self.__LCOS__ = None        self.__inputElectricity__ = None        self.__outputElectricity__ = None        self.__roundtripEfficiency__ = None    """ Assign static method """    @staticmethod    def _assign(obj, *,                dischargeDuration: float | None = None,  # nominal discharge duration [s]                dischargingPower: float | None = None,  # nominal discharging power [W]                chargeDuration: float | None = None,  # nominal charge duration [s]                chargingPower: float | None = None,  # nominal charging power [W]                roundtripEfficiency: float | None = None,  # (x > 0)                powerIslandSpecificCost: float | None = None,  # [$/kW]                storeSpecificCost: float | None = None,  # [$/kWh]                selfDischargeRate: float | None = None,  # [%/h]                secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                secondaryConsumptionRatio: float | None = None,  # gas consumption ratio upon discharge [kWh_g / kWh_e]                electricityPrice: float | None = None,  # [$/MWh]                gasPrice: float | None = None,  # [$/MWh]                hydrogenPrice: float | None = None,  # [$/MWh]                frequency: float | None = None,  # number of cycles per year [#/year]                lifetime: int | None = None,                discountRate: float | None = None,                standby: float | None = None                ):        # Check validity of dischargeDuration and assign if correct        if dischargeDuration is not None:            if dischargeDuration >= 0:                obj._dischargeDuration = dischargeDuration            else:                raise ValueError('dischargeDuration must be positive.')        # Check validity of chargeDuration and assign if correct        if chargeDuration is not None:            if chargeDuration >= 0:                obj._chargeDuration = chargeDuration            else:                raise ValueError('chargeDuration must be positive.')        # Check validity of dischargingPower and assign if correct        if dischargingPower is not None:            if dischargingPower >= 0:                obj._dischargingPower = dischargingPower            else:                raise ValueError('dischargingPower must be positive.')        # Check validity of chargingPower and assign if correct        if chargingPower is not None:            if chargingPower >= 0:                obj._chargingPower = chargingPower            else:                raise ValueError('chargingPower must be positive.')        # Check validity of round-trip efficiency and assign if correct        if roundtripEfficiency is not None:            if 0 <= roundtripEfficiency:                obj._nominalRoundtripEfficiency = roundtripEfficiency            else:                raise ValueError('Electricity-to-electricity roundtrip efficiency must be greater than 0.')        # Check / enforce validity of energy input / output        W_in = obj.nominalChargingPower_MW        dt_in = obj.nominalChargeDuration_hours        W_out = obj.nominalDischargingPower_MW        dt_out = obj.nominalDischargeDuration_hours        eta = obj.nominalRoundTripEfficiency        parameters = [W_in, dt_in, W_out, dt_out, eta]        if None not in parameters:            if not np.isclose((W_out * dt_out) / (W_in * dt_in), eta):                raise ValueError("Inconsistent charge/discharge and efficiency values.")        elif parameters.count(None) == 1:            if dt_in is None:                obj._chargeDuration = W_out * dt_out / (eta * W_in) * 3600            elif W_in is None:                obj._chargingPower = W_out * dt_out / (eta * dt_in) / 1e6            elif eta is None:                obj._nominalRoundtripEfficiency = (W_out * dt_out) / (W_in * dt_in)            elif dt_out is None:                obj._dischargeDuration = eta * W_in * dt_in / W_out * 3600            elif W_out is None:                obj._dischargingPower = eta * W_in * dt_in / dt_out / 1e6        # Check validity of powerIslandSpecificCost and assign if correct        if powerIslandSpecificCost is not None:            if powerIslandSpecificCost >= 0:                obj._powerIslandSpecificCost = powerIslandSpecificCost            else:                raise ValueError('powerIslandSpecificCost must be positive.')        # Check validity of storeSpecificCost_per_kWh and assign if correct        if storeSpecificCost is not None:            if storeSpecificCost >= 0:                obj._storeSpecificCost = storeSpecificCost            else:                raise ValueError('storeSpecificCost_per_kWh must be positive.')        # Check validity of electricityPrice and assign if correct        if electricityPrice is not None:            if electricityPrice >= 0:                obj._electricityPrice = electricityPrice            else:                raise ValueError('electricityPrice must be positive.')        # Check validity of gasPrice and assign if correct        if gasPrice is not None:            if gasPrice >= 0:                obj._gasPrice = gasPrice            else:                raise ValueError('gasPrice must be positive.')        # Check validity of hydrogenPrice and assign if correct        if hydrogenPrice is not None:            if hydrogenPrice >= 0:                obj._hydrogenPrice = hydrogenPrice            else:                raise ValueError('hydrogenPrice must be positive.')        # Check validity of secondaryConsumptionRatio and assign if correct        if secondaryConsumptionRatio is not None:            if secondaryConsumptionRatio >= 0:                obj._secConsumptionRatio = secondaryConsumptionRatio            else:                raise ValueError('secondaryConsumptionRatio must be positive.')        # Check validity of self-discharge rate and assign if correct        if selfDischargeRate is not None:            if 0 <= selfDischargeRate <= 1:                obj._selfDischargeRate = selfDischargeRate            else:                raise ValueError('Self-discharge rate must lie between 0 and 1')        # Check validity of the secondary source and assign if correct        if secondarySource is not None:            if secondarySource in ['electricity', 'gas', 'hydrogen']:                obj._secSource = secondarySource            else:                raise ValueError('Secondary fuel must be either electricity, gas or hydrogen.')        # Check validity of frequency and assign if correct        if frequency is not None:            if frequency >= 0:                obj._frequency = frequency            else:                raise ValueError('Frequency must be greater than 1.')        # Check validity of lifetime and assign if correct        if lifetime is not None:            if lifetime >= 1:                obj._lifetime = lifetime            else:                raise ValueError('Lifetime must be an integer greater than 1.')        # Check validity of discount rate and assign if correct        if discountRate is not None:            if 0 <= discountRate <= 1:                obj._discountRate = discountRate            else:                raise ValueError('Discount rate must lie between 0 and 1')        # Check validity of non-dimensional standby duration and assign if correct        if standby is not None:            if 0 <= standby <= 1:                obj._standby = standby            else:                raise ValueError('standby rate must lie between 0 and 1')        return obj    """ Update methods """    def updateOperatingConditions(self,                                  frequency: float | None = None,  # number of cycles per year [#/year]                                  standby: float | None = None                                  ):        self._resetGhostProperties()        self._assign(obj=self,                     frequency=frequency,                     standby=standby)    def updateDiscountRate(self, discountRate: float):        if 0 <= discountRate <= 1:            self._discountRate = discountRate        else:            raise ValueError('Discount rate must lie between 0 and 1.')    def updateEnergyPrices(self, currency: str, *,                           electricity: float | None = None,                           gas: float | None = None,                           hydrogen: float | None = None):        self._resetGhostProperties()        # Conversion factor        dataCurrencyIndex = currencyIndex(currency)        k = self.__currencyIndex__() / dataCurrencyIndex        if electricity is not None:            if electricity >= 0:                self._electricityPrice = electricity * k            else:                raise ValueError('Electricity price must be positive.')        if gas is not None:            if gas >= 0:                self._gasPrice = gas * k            else:                raise ValueError('Gas price must be positive.')        if hydrogen is not None:            if hydrogen >= 0:                self._hydrogenPrice = hydrogen * k            else:                raise ValueError('Hydrogen price must be positive.')    def updateScene(self):        previousCEPCI = self.CEPCI        # Get the scene        scene = getTheScene()        Country = scene['Country']        Year = int(scene['Year'])        # Location- and time-specific data        self._year: int = Year if isinstance(Year, int) else None        self._country: str = Country if isinstance(Country, str) else None        # Reset scene-dependent ghost properties        self._resetSceneDependentGhostProperties()        # Collect new CEPCI        newCEPCI = self.CEPCI        # Conversion factor        r = newCEPCI / previousCEPCI        # Scene-dependent private properties        if isinstance(self._powerIslandSpecificCost, Iterable):            self._powerIslandSpecificCost = [x * r for x in self._powerIslandSpecificCost]        else:            self._powerIslandSpecificCost = self._powerIslandSpecificCost * r        if isinstance(self._storeSpecificCost, Iterable):            self._storeSpecificCost = [x * r for x in self._storeSpecificCost]        else:            self._storeSpecificCost = self._storeSpecificCost * r    """ Units and conversion methods """    @property    def units(self):        return self._units    @property    def currency(self):        currency = self._units['currency']        return ureg[currency].units    def __currencyIndex__(self) -> float | None:        return currencyIndex(self.currency)    def convertQuantity(self, value: ureg.Quantity, *, inflationRatio: float = 1.) -> ureg.Quantity:        if not value.dimensionless:            for dimension, unit in self.units.items():                if value.dimensionality == ureg[unit].dimensionality:                    if '[currency]' in value.dimensionality:                        value = value.to(self.units[dimension], 'conversion') * inflationRatio                    else:                        value = value.to(self.units[dimension])        return value    """ Location and time-specific data """    @property    def year(self) -> int:        return self._year    @property    def country(self) -> str:        return self._country    """ System designation """    @property    def type(self):        return self._type    """ Battery technical characteristics (size) """    @property    def nominalDischargeDuration_hours(self):        if self._dischargeDuration is None:            return None        else:            return self._dischargeDuration    @property    def nominalChargeDuration_hours(self):        if self._chargeDuration is None:            return None        else:            return self._chargeDuration    @property    def nominalDischargingPower_MW(self):        if self._dischargingPower is None:            return None        else:            return self._dischargingPower    @property    def nominalChargingPower_MW(self):        if self._chargingPower is None:            return None        else:            return self._chargingPower    """ Technical performance """    @property    def nominalRoundTripEfficiency(self):        return self._nominalRoundtripEfficiency    @property    def selfDischargeRate_percentPerHour(self):        return self._selfDischargeRate    @property    def secondarySource(self) -> str | None:        return self._secSource    """ Secondary fuel / energy vector """    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        return self._secConsumptionRatio    @property    def secondarySourceInput_MWh(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if not self.secondarySourceConsumptionRatio:            return 0.        else:            r = self.secondarySourceConsumptionRatio            W_out = self.outputElectricity_MWh            if None not in [W_out, r]:                return W_out * r            else:                return None    """ Economic value """    @property    def powerIslandSpecificCost(self) -> float | None:        return self._powerIslandSpecificCost    @property    def storeSpecificCost_per_kWh(self) -> float | None:        return self._storeSpecificCost    """ Economic conditions (scenario- & country-dependent parameters) """    @property    def electricityPrice(self) -> float | None:        return self._electricityPrice    @property    def gasPrice(self) -> float | None:        return self._gasPrice    @property    def hydrogenPrice(self) -> float | None:        return self._hydrogenPrice    @property    def discountRate(self) -> float | None:        return self._discountRate    @property    def wholesaleElectricityPrice(self) -> float | None:        return self.__wholesaleElectricityPrice__    @property    def CEPCI(self) -> float | None:        if self.__CEPCI__ is None:            if self.year in CEPCI.index:                self.__CEPCI__ = float(CEPCI[self.year])            else:                warnings.warn(f'The CEPCI is not available for {self.year}.')        return self.__CEPCI__    """ Utilisation / operational parameters """    @property    def lifetime(self) -> int | None:        return self._lifetime    @property    def frequency(self) -> float | None:        if self._frequency is not None:            return self.maximumFrequency if self._frequency > self.maximumFrequency else self._frequency        else:            return None    """ Dependent properties """    @property    def wholeCycleDuration_hours(self) -> float | None:        if self.__wholeCycleDuration__ is None:            f = self.frequency            if f is not None:                self.__wholeCycleDuration__ = 8760 / f        return self.__wholeCycleDuration__    @property    def standbyDuration_hours(self) -> float | None:        if self.__standbyDuration__ is None:            dt = self.wholeCycleDuration_hours            dt_w = self.workingCycleDuration_hours            dt_norm_stb = self._standby            if None not in [dt, dt_w, dt_norm_stb]:                dt_idle = dt - dt_w                self.__standbyDuration__ = dt_norm_stb * dt_idle        return self.__standbyDuration__    @property    def workingCycleDuration_hours(self) -> float | None:        if self.__workingCycleDuration__ is None:            dt_discharge = self.nominalDischargeDuration_hours  # [s]            dt_charge = self.nominalChargeDuration_hours  # [h]            if None not in [dt_discharge, dt_charge]:                self.__workingCycleDuration__ = (dt_discharge + dt_charge)        return self.__workingCycleDuration__    @property    def storageCapacity_MWh(self) -> float | None:        if self.__storageCapacity__ is None:            # Gather inputs parameters            dt = self._dischargeDuration  # [s]            W = self._dischargingPower  # [W]            if None not in [W, dt]:                self.__storageCapacity__ = W * dt / 3600 / 1e6        return self.__storageCapacity__    @property    def investmentCost(self) -> float | None:        if self.__investmentCost__ is None:            # Gather inputs parameters            cost_per_kW = self.powerIslandSpecificCost  # [$/kW]            cost_per_kWh = self.storeSpecificCost_per_kWh  # [$/kWh]            MW = self.nominalDischargingPower_MW            MWh = self.storageCapacity_MWh            if None not in [MW, MWh, cost_per_kWh, cost_per_kW]:                self.__investmentCost__ = MW * cost_per_kW * 1e3 + MWh * cost_per_kWh * 1e3        return self.__investmentCost__    @property    def maximumFrequency(self) -> int | None:        if self.__maximumFrequency__ is None:            # Gather inputs parameters            cycleDuration = self.workingCycleDuration_hours            if cycleDuration is not None:                self.__maximumFrequency__ = int(8760 / cycleDuration)        return self.__maximumFrequency__    @property    def inputElectricity_MWh(self) -> float | None:        if self.__inputElectricity__ is None:            # Gather inputs parameters            MW = self.nominalChargingPower_MW            hours = self.nominalChargeDuration_hours            if None not in [MW, hours]:                self.__inputElectricity__ = MW * hours        return self.__inputElectricity__    @property    def outputElectricity_MWh(self) -> float | None:        if self.__outputElectricity__ is None:            # Gather inputs parameters            W_in = self.inputElectricity_MWh            dWdt = self.selfDischargeRate_percentPerHour / 100            dt_stb = self.standbyDuration_hours            eta = self.nominalRoundTripEfficiency            if None not in [W_in, dWdt, dt_stb, eta]:                W_st = W_in * (1 - dWdt) ** dt_stb                self.__outputElectricity__ = eta * W_st if W_st > 0 else 0        return self.__outputElectricity__    @property    def roundtripEfficiency(self):        if self.__roundtripEfficiency__ is None:            W_in = self.inputElectricity_MWh            W_out = self.outputElectricity_MWh            if None not in [W_in, W_out]:                self.__roundtripEfficiency__ = W_out / W_in        return self.__roundtripEfficiency__    @property    def levelisedCostOfStorage(self) -> float | list[float] | None:        if self.__LCOS__ is None:            # Gather inputs parameters            investmentCost = self.investmentCost            W_in_MWh = self.inputElectricity_MWh            W_out_MWh = self.outputElectricity_MWh            i = self.discountRate            n = self.lifetime            f = self.frequency            C_el = self.electricityPrice  # $/MWh            Q_sec_Mwh = self.secondarySourceInput_MWh            C_sec = 0 if not self.secondarySource \                else self.gasPrice if self.secondarySource == 'gas' \                else self.hydrogenPrice if self.secondarySource == 'hydrogen' \                else None            if None not in [investmentCost, i, n, W_in_MWh, W_out_MWh, f, Q_sec_Mwh, C_sec]:                n = np.arange(1, n)                discount = (1 + i) ** n                # Upfront costs                C_inv = investmentCost                # Discounted operational costs                yearlyConsumption = W_in_MWh * C_el * f + Q_sec_Mwh * C_sec * f                C_op = (yearlyConsumption / discount).sum()                # Discounted electricity recovered                yearlyDischarge = W_out_MWh * f                W_kWh = (yearlyDischarge / discount).sum()                self.__LCOS__ = (C_inv + C_op) / W_kWh  # [$/kWh]                if isinstance(self.__LCOS__, Iterable):                    self.__LCOS__ = [float(x) for x in self.__LCOS__]        return self.__LCOS__""" SYSTEMS """class ElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()    def factory(self) -> ElectricityStorageTechnology:        return ElectricityStorageTechnology()    def withInputs(self, *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   dischargingPower: float | None = None,  # nominal discharging power [W]                   chargeDuration: float | None = None,  # nominal charge duration [s]                   chargingPower: float | None = None,  # nominal charging power [W]                   roundtripEfficiency: float | None = None,  # (instantaneous) roundtrip efficiency (x > 0)                   powerIslandSpecificCost: float | None = None,  # power-specific cost of the power island [$/kW]                   storeSpecificCost: float | None = None,  # energy-specific cost of the store [$/kWh]                   selfDischargeRate: float = 0,  # self-discharge rate [%/h]                   secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                   secondaryConsumptionRatio: float | None = 0,  # gas consumption ratio upon discharge [kWh_g / kWh_e]                   discountRate: float | None = None,                   frequency: float | None = None,                   lifetime: int | None = None,                   standby: float | None = 1.) -> ElectricityStorageTechnology:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            roundtripEfficiency=roundtripEfficiency,            powerIslandSpecificCost=powerIslandSpecificCost,            storeSpecificCost=storeSpecificCost,            selfDischargeRate=selfDischargeRate,            secondarySource=secondarySource,            secondaryConsumptionRatio=secondaryConsumptionRatio,            frequency=frequency,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return objclass DataDrivenElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    """ Data stored in pystorage/data folder as csv files with the following fields and second header indicating unit:    duration, power,    roundtripEfficiency, secondaryConsumptionRatio,    powerIslandSpecificCost_LB, powerIslandSpecificCost, powerIslandSpecificCost_UB,    storeSpecificCost_LB, storeSpecificCost, storeSpecificCost_UB    Ex:    h,MW,%,W/W,USD/kW,USD/kW,USD/kW,USD/kWh,USD/kWh,USD/kWh    4, 100, 74.6, 1.189, 945.25, 1050.28, 1155.3, 2.76, 9.99, 16.59    """    def __init__(self):        super().__init__()        # Collected data        self._data = None        self._type: str | None = None        self._model: str | None = None        # Scattered interpolation for predicting techno-economic value        LND = LinearNDInterpolator([[0, 0], [1, 0], [0, 1], [1, 1]], [0, 1, 2, 4])        self.scatteredInterpolation = {            'roundtripEfficiency': LND,            'secondaryConsumptionRatio': LND,            'powerIslandSpecificCost': LND,            'storeSpecificCost': LND,            'powerIslandSpecificCost_LB': LND,            'storeSpecificCost_LB': LND,            'powerIslandSpecificCost_UB': LND,            'storeSpecificCost_UB': LND,        }        # # Scattered interpolation for technical performance        # self._roundtripEfficiency_int: LinearNDInterpolator | None = None  # e-to-e ratio [W_out / W_in]        # self._secConsumptionRatio_int: LinearNDInterpolator | None = None  # consumption ratio [kWh_g / kWh_e]        #        # # Scattered interpolation for power island SIC        # self._powerIslandSIC_int: LinearNDInterpolator | None = None        # self._powerIslandSIC_LB_int: LinearNDInterpolator | None = None        # self._powerIslandSIC_UB_int: LinearNDInterpolator | None = None        #        # # Scattered interpolation for store SIC        # self._storeSIC_int: LinearNDInterpolator | None = None        # self._storeSIC_LB_int: LinearNDInterpolator | None = None        # self._storeSIC_UB_int: LinearNDInterpolator | None = None    """ Factory & reset methods """    def factory(self) -> DataDrivenElectricityStorageTechnology:        return DataDrivenElectricityStorageTechnology()    def _resetGhostProperties(self):        super()._resetGhostProperties()        # Design-dependent private properties        self._nominalRoundtripEfficiency = None        self._secConsumptionRatio = None        self._powerIslandSpecificCost = None        self._storeSpecificCost = None    """ Assign static & dynamic methods """    @staticmethod    def _assignData(obj, data, currency, year):        # Store data        obj._data = data        # Inflation        inflationRatio = obj.CEPCI / CEPCI[year]        # Convert data        for key, values in data.items():            data[key] = obj.convertQuantity(value=values, inflationRatio=inflationRatio).magnitude        # Create linear N-D interpolation methods        for key, values in data.items():            if key in obj.scatteredInterpolation.keys():                obj.scatteredInterpolation[key] = LinearNDInterpolator(                    points=list(zip(data['duration'], data['power'])), values=values)        return obj    def withInputs(self, dataSource: str,                   *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   dischargingPower: float | None = None,  # nominal discharging power [W]                   chargeDuration: float | None = None,  # nominal charge duration [s]                   chargingPower: float | None = None,  # nominal charging power [W]                   selfDischargeRate: float = 0,  # self-discharge rate [%/h]                   discountRate: float | None = None,                   frequency: float | None = None,                   lifetime: int | None = None,                   standby: float | None = 1.) -> DataDrivenElectricityStorageTechnology:        obj = self.factory()        if dataSource == 'PNNL_CAES':            obj._type = 'D-CAES'            obj._model = 'PNNL'            obj._secSource = 'gas'            obj._assignData(obj, data=PNNL_CAES, currency='USD', year=2023)        else:            raise ValueError(f'No data available for {dataSource}')        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            selfDischargeRate=selfDischargeRate,            frequency=frequency,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return obj    """ Update methods """    def updateDataSource(self, dataSource: str):        self._resetGhostProperties()        if dataSource == 'PNNL_CAES':            self._type = 'D-CAES'            self._model = 'PNNL'            self._secSource = 'gas'            self._assignData(self, data=PNNL_CAES, currency='USD', year=2023)        else:            raise ValueError(f'No data available for {dataSource}')    def updateDesign(self, *,                     dischargeDuration: float | None = None,  # nominal discharge duration [s]                     dischargingPower: float | None = None,  # nominal discharging power [W]                     chargeDuration: float | None = None,  # nominal charge duration [s]                     chargingPower: float | None = None,  # nominal charging power [W]                     selfDischargeRate: float = 0,  # self-discharge rate [%/h]                     lifetime: int | None = None                     ):        # Reset ghost properties        self._resetGhostProperties()        self._assign(obj=self,                     dischargeDuration=dischargeDuration,                     dischargingPower=dischargingPower,                     chargeDuration=chargeDuration,                     chargingPower=chargingPower,                     selfDischargeRate=selfDischargeRate,                     lifetime=lifetime)    """ Dependent properties """    @property    def model(self) -> str:        return self._model    @property    def nominalRoundTripEfficiency(self) -> float | None:        if self._nominalRoundtripEfficiency is None:            hours = self.nominalDischargeDuration_hours.magnitude            kW = self.nominalDischargingPower_MW.magnitude * 1e3            if None not in [hours, kW]:                function = self.scatteredInterpolation['roundtripEfficiency']                value = function(hours, kW)                self._nominalRoundtripEfficiency = float(value) * ureg[self.units['efficiency']]        return self._nominalRoundtripEfficiency    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if self._secConsumptionRatio is None:            hours = self.nominalDischargeDuration_hours.magnitude            kW = self.nominalDischargingPower_MW.magnitude * 1e3            if None not in [hours, kW]:                function = self.scatteredInterpolation['secondaryConsumptionRatio']                value = function(hours, kW)                self._secConsumptionRatio = float(value)         return self._secConsumptionRatio    @property    def powerIslandSpecificCost(self) -> list[float] | None:        if self._powerIslandSpecificCost is None:            hours = self.nominalDischargeDuration_hours.magnitude            kW = self.nominalDischargingPower_MW.magnitude * 1e3            if None not in [hours, kW]:                # Lower bound                function = self.scatteredInterpolation['powerIslandSpecificCost_LB']                value = function(hours, kW)                self._powerIslandSpecificCost = [float(value) * ureg[self.units['powerSpecificCost']]]                # Mean value                function = self.scatteredInterpolation['powerIslandSpecificCost']                value = function(hours, kW)                self._powerIslandSpecificCost.append(float(value) * ureg[self.units['powerSpecificCost']])                # Upper bound                function = self.scatteredInterpolation['powerIslandSpecificCost_UB']                value = function(hours, kW)                self._powerIslandSpecificCost.append(float(value) * ureg[self.units['powerSpecificCost']])        return self._powerIslandSpecificCost    @property    def storeSpecificCost_per_kWh(self) -> list[float] | None:        if self._storeSpecificCost is None:            baseCEPCI = CEPCI[2023]            currentCEPCI = self.CEPCI            hours = self.nominalDischargeDuration_hours            MW = self.nominalDischargingPower_MW            if None not in [hours, MW, currentCEPCI]:                # Specific cost interpolation                cost = self._storeSIC_int(hours, MW)                lowCost = self._storeSIC_LB_int(hours, MW)                highCost = self._storeSIC_UB_int(hours, MW)                # Inflation                cost = cost * (currentCEPCI / baseCEPCI)                lowCost = lowCost * (currentCEPCI / baseCEPCI)                highCost = highCost * (currentCEPCI / baseCEPCI)                self._storeSpecificCost = [lowCost, cost, highCost] * ureg[self._units['EnergySpecificCost']]        return self._storeSpecificCost    @property    def investmentCost(self) -> list[float] | None:        if self.__investmentCost__ is None and self.powerIslandSpecificCost is not None:            self.__investmentCost__ = []            for n in np.arange(len(self.powerIslandSpecificCost)):                # Gather inputs parameters                cost_per_kW = self.powerIslandSpecificCost[n]  # [$/kW]                cost_per_kWh = self.storeSpecificCost_per_kWh[n]  # [$/kWh]                MW = self.nominalDischargingPower_MW                MWh = self.storageCapacity_MWh                if None not in [MW, MWh, cost_per_kWh, cost_per_kW]:                    kWh = MWh * 1e3                    kW = MW * 1e3                    self.__investmentCost__.append(float(kW * cost_per_kW + kWh * cost_per_kWh))        return self.__investmentCost__class DiabaticCAES(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()        self._type = 'D-CAES'        self._model = 'firstLaw'    def factory(self) -> DiabaticCAES:        return DiabaticCAES()    def withDesign(self, *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   power: float | None = None,  # nominal discharging power [W]                   selfDischargeRate: float = 0  # self-discharge rate [%/h]                   ) -> DiabaticCAES:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=power,            chargingPower=power,            selfDischargeRate=selfDischargeRate,            roundtripEfficiency=self._nominalRoundtripEfficiency,            secondarySource=self._secSource,            secondaryConsumptionRatio=self._secConsumptionRatio)        return obj    @property    def model(self) -> str:        return self._model