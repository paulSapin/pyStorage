from __future__ import annotationsimport warningsimport numpy as npfrom scipy.interpolate import LinearNDInterpolatorfrom abc import ABC, abstractmethodfrom collections.abc import Iterablefrom ..data import CEPCI, PNNL_CAES, currencyIndexfrom ..config import getTheScene, getUnits, uregimport copyQ_ = ureg.Quantity""" ABSTRACT CLASS """class _AbstractElectricityStorageTechnology(ABC):    @abstractmethod    def __init__(self):        # Get the scene        scene = getTheScene()        self._country = scene['Country']        self._year = int(scene['Year'])        # Get currency        self._units = getUnits()        self._currency = self._units['currency']        # Battery type        self._type: str | None = None  # PHES / LAES / (A-D-I-)CAES / PTES / Flow / LiIon / Flywheel        # Battery technical characteristics (size)        self._dischargeDuration: Q_ | None = None  # Discharge duration [s]        self._dischargingPower: Q_ | None = None  # Discharging rate/power [W]        self._chargeDuration: Q_ | None = None  # Charge duration [s]        self._chargingPower: Q_ | None = None  # Charging rate/power [W]        # Battery technical performance        self._nominalRoundtripEfficiency: Q_ | None = None  # Electricity-to-electricity roundtrip efficiency        self._selfDischargeRate: Q_ | None = None  # Self-discharge rate [0 - 1]        # Secondary fuel / energy vector        self._secSource: str | None = None  # Secondary energy source             (e.g., gas, H2)        self._secConsumptionRatio: float | None = None  # Consumption ratio upon discharge [kWh_g / kWh_e]        # Battery economic value (scene-dependent as depend on CEPCI)        self._powerIslandSpecificCost: Q_ | None = None  # [$/kW]        self._storeSpecificCost: Q_ | None = None  # [$/kWh]        # Economic conditions (scenario-, year- & country-dependent parameters)        self._electricityPrice: Q_ | None = None  # (Mean) electricity price [$/MWh]        self._gasPrice: Q_ | None = None  # (Mean) gas price [$/MWh]        self._hydrogenPrice: Q_ | None = None  # (Mean) hydrogen price [$/MWh]        self._discountRate: Q_ | None = None  # Discount rate [0-1]        # Utilisation / operational parameters        self._lifetime: Q_ | None = None  # System lifetime [years]        self._cyclesPerYear: int | None = None  # Number of cycles / year [1 - maxFreq]        self._standby: float | None = None  # Non-dimensional standby duration [0 - 1]        # Scene-dependent ghost properties        self.__wholesaleElectricityPrice__: Q_ | None = None  # Time-resolved electricity tariff [$/MWh]        self.__wholesaleGasPrice__: Q_ | None = None  # Time-resolved gas tariff [$/MWh]        self.__investmentCost__: Q_ | None = None        self.__CEPCI__: Q_ | None = None  # Chemical Engineering Plant Cost Index (CEPCI)        self.__LCOS__: Q_ | None = None        # Technical ghost dependent properties        self.__workingCycleDuration__: Q_ | None = None        self.__wholeCycleDuration__: Q_ | None = None        self.__standbyDuration__: Q_ | None = None        self.__maximumCyclesPerYear__: int | None = None        self.__storageCapacity__: Q_ | None = None        self.__inputElectricity__: Q_ | None = None        self.__outputElectricity__: Q_ | None = None        self.__roundtripEfficiency__: Q_ | None = None    """ Factory & reset methods """    @abstractmethod    def factory(self) -> _AbstractElectricityStorageTechnology:        raise NotImplementedError  # pragma: no cover    def _resetSceneDependentGhostProperties(self):        # Scene-dependent ghost properties        self.__wholesaleElectricityPrice__ = None        self.__wholesaleGasPrice__ = None        self.__investmentCost__ = None        self.__CEPCI__ = None        self.__LCOS__ = None    def _resetGhostProperties(self):        self.__workingCycleDuration__ = None        self.__wholeCycleDuration__ = None        self.__standbyDuration__ = None        self.__maximumCyclesPerYear__ = None        self.__investmentCost__ = None        self.__storageCapacity__ = None        self.__LCOS__ = None        self.__inputElectricity__ = None        self.__outputElectricity__ = None        self.__roundtripEfficiency__ = None    """ Assign static method """    @staticmethod    def _assign(obj, *,                dischargeDuration: Q_ | None = None,  # nominal discharge duration [s]                dischargingPower: Q_ | None = None,  # nominal discharging power [W]                chargeDuration: Q_ | None = None,  # nominal charge duration [s]                chargingPower: Q_ | None = None,  # nominal charging power [W]                roundtripEfficiency: Q_ | None = None,  # (x > 0)                powerIslandSpecificCost: Q_ | None = None,  # [$/kW]                storeSpecificCost: Q_ | None = None,  # [$/kWh]                selfDischargeRate: Q_ | None = None,  # [%/h]                secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                secondaryConsumptionRatio: Q_ | None = None,  # upon discharge [kWh_g / kWh_e]                electricityPrice: Q_ | None = None,  # [$/MWh]                gasPrice: Q_ | None = None,  # [$/MWh]                hydrogenPrice: Q_ | None = None,  # [$/MWh]                cyclesPerYear: int | None = None,  # number of cycles per year [#/year]                lifetime: Q_ | None = None,  # [years]                discountRate: Q_ | None = None,                standby: Q_ | None = None                ):        # Check validity of dischargeDuration and assign if correct        if dischargeDuration is not None:            if dischargeDuration.magnitude >= 0:                obj._dischargeDuration = obj.convertQuantity(dischargeDuration)            else:                raise ValueError('dischargeDuration must be positive.')        # Check validity of chargeDuration and assign if correct        if chargeDuration is not None:            if chargeDuration.magnitude >= 0:                obj._chargeDuration = obj.convertQuantity(chargeDuration)            else:                raise ValueError('chargeDuration must be positive.')        # Check validity of dischargingPower and assign if correct        if dischargingPower is not None:            if dischargingPower.magnitude >= 0:                obj._dischargingPower = obj.convertQuantity(dischargingPower)            else:                raise ValueError('dischargingPower must be positive.')        # Check validity of chargingPower and assign if correct        if chargingPower is not None:            if chargingPower.magnitude >= 0:                obj._chargingPower = obj.convertQuantity(chargingPower)            else:                raise ValueError('chargingPower must be positive.')        # Check validity of round-trip efficiency and assign if correct        if roundtripEfficiency is not None:            if 0 <= roundtripEfficiency.magnitude:                obj._nominalRoundtripEfficiency = obj.convertQuantity(roundtripEfficiency)            else:                raise ValueError('Electricity-to-electricity roundtrip efficiency must be greater than 0.')        # Check / enforce validity of energy input / output        W_in = obj.nominalChargingPower.magnitude if obj.nominalChargingPower is not None else None        dt_in = obj.nominalChargeDuration.magnitude if obj.nominalChargeDuration is not None else None        W_out = obj.nominalDischargingPower.magnitude if obj.nominalDischargingPower is not None else None        dt_out = obj.nominalDischargeDuration.magnitude if obj.nominalDischargeDuration is not None else None        eta = obj.nominalRoundTripEfficiency.to('').magnitude if obj.nominalRoundTripEfficiency is not None else None        parameters = [W_in, dt_in, W_out, dt_out, eta]        if None not in parameters:            if not np.isclose((W_out * dt_out) / (W_in * dt_in), eta):                raise ValueError("Inconsistent charge/discharge and efficiency values.")        elif parameters.count(None) == 1:            if dt_in is None:                obj._chargeDuration = W_out * dt_out / (eta * W_in) * ureg(obj.units['time'])            elif W_in is None:                obj._chargingPower = W_out * dt_out / (eta * dt_in) * ureg(obj.units['power'])            elif eta is None:                obj._nominalRoundtripEfficiency = (W_out * dt_out) / (W_in * dt_in) * ureg(obj.units['efficiency'])            elif dt_out is None:                obj._dischargeDuration = eta * W_in * dt_in / W_out * ureg(obj.units['time'])            elif W_out is None:                obj._dischargingPower = eta * W_in * dt_in / dt_out * ureg(obj.units['power'])        # Check validity of powerIslandSpecificCost and assign if correct        if powerIslandSpecificCost is not None:            if powerIslandSpecificCost.magnitude >= 0:                obj._powerIslandSpecificCost = obj.convertQuantity(powerIslandSpecificCost)            else:                raise ValueError('powerIslandSpecificCost must be positive.')        # Check validity of storeSpecificCost and assign if correct        if storeSpecificCost is not None:            if storeSpecificCost.magnitude >= 0:                obj._storeSpecificCost = obj.convertQuantity(storeSpecificCost)            else:                raise ValueError('storeSpecificCost must be positive.')        if electricityPrice is not None:            if electricityPrice.magnitude >= 0:                obj._electricityPrice = obj.convertQuantity(electricityPrice)            else:                raise ValueError('Electricity price must be positive.')        if gasPrice is not None:            if gasPrice.magnitude >= 0:                obj._gasPrice = obj.convertQuantity(gasPrice)            else:                raise ValueError('Gas price must be positive.')        if hydrogenPrice is not None:            if hydrogenPrice.magnitude >= 0:                obj._hydrogenPrice = obj.convertQuantity(hydrogenPrice)            else:                raise ValueError('Hydrogen price must be positive.')        # Check validity of secondaryConsumptionRatio and assign if correct        if secondaryConsumptionRatio is not None:            if secondaryConsumptionRatio.magnitude >= 0:                obj._secConsumptionRatio = secondaryConsumptionRatio            else:                raise ValueError('secondaryConsumptionRatio must be positive.')        # Check validity of self-discharge rate and assign if correct        if selfDischargeRate is not None:            if 0 <= selfDischargeRate.magnitude <= 100:                obj._selfDischargeRate = obj.convertQuantity(selfDischargeRate)            else:                raise ValueError('Self-discharge rate must lie between 0 and 1')        # Check validity of the secondary source and assign if correct        if secondarySource is not None:            if secondarySource in ['electricity', 'gas', 'hydrogen']:                obj._secSource = secondarySource            else:                raise ValueError('Secondary fuel must be either electricity, gas or hydrogen.')        # Check validity of cyclesPerYear and assign if correct        if cyclesPerYear is not None:            if cyclesPerYear >= 0:                obj._cyclesPerYear = cyclesPerYear            else:                raise ValueError('CyclesPerYear must be greater than 1.')        # Check validity of lifetime and assign if correct        if lifetime is not None:            if lifetime.magnitude >= 1:                obj._lifetime = lifetime            else:                raise ValueError('Lifetime must be an integer greater than 1.')        # Check validity of discount rate and assign if correct        if discountRate is not None:            if 0 <= discountRate.magnitude <= 100:                obj._discountRate = discountRate            else:                raise ValueError('Discount rate must lie between 0 and 1')        # Check validity of non-dimensional standby duration and assign if correct        if standby is not None:            if 0 <= standby <= 1:                obj._standby = standby            else:                raise ValueError('standby rate must lie between 0 and 1')        return obj    """ Update methods """    def update(self, *,               dischargeDuration: Q_ | None = None,  # nominal discharge duration [s]               dischargingPower: Q_ | None = None,  # nominal discharging power [W]               chargeDuration: Q_ | None = None,  # nominal charge duration [s]               chargingPower: Q_ | None = None,  # nominal charging power [W]               roundtripEfficiency: Q_ | None = None,  # (x > 0)               powerIslandSpecificCost: Q_ | None = None,  # [$/kW]               storeSpecificCost: Q_ | None = None,  # [$/kWh]               selfDischargeRate: Q_ | None = None,  # [%/h]               secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)               secondaryConsumptionRatio: Q_ | None = None,  # upon discharge [kWh_g / kWh_e]               electricityPrice: Q_ | None = None,  # [$/MWh]               gasPrice: Q_ | None = None,  # [$/MWh]               hydrogenPrice: Q_ | None = None,  # [$/MWh]               cyclesPerYear: int | None = None,  # number of cycles per year [#/year]               lifetime: Q_ | None = None,  # [years]               discountRate: Q_ | None = None,               standby: Q_ | None = None               ):        self._resetGhostProperties()        self._assign(            self,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            roundtripEfficiency=roundtripEfficiency,            powerIslandSpecificCost=powerIslandSpecificCost,            storeSpecificCost=storeSpecificCost,            selfDischargeRate=selfDischargeRate,            secondarySource=secondarySource,            secondaryConsumptionRatio=secondaryConsumptionRatio,            electricityPrice=electricityPrice,            gasPrice=gasPrice,            hydrogenPrice=hydrogenPrice,            cyclesPerYear=cyclesPerYear,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)    def updateScene(self):        previousCEPCI = self.CEPCI        # Get the scene        scene = getTheScene()        self._country = scene['Country']        self._year = int(scene['Year'])        # Reset scene-dependent ghost properties        self._resetSceneDependentGhostProperties()        # Collect new CEPCI        newCEPCI = self.CEPCI        # Conversion factor        r = newCEPCI / previousCEPCI        # Scene-dependent private properties        if self._powerIslandSpecificCost is not None and self._storeSpecificCost is not None:            self._powerIslandSpecificCost = self._powerIslandSpecificCost * r            self._storeSpecificCost = self._storeSpecificCost * r    """ Units and conversion methods """    @property    def units(self):        return self._units    @property    def currency(self):        currency = self._units['currency']        return ureg[currency].units    def __currencyIndex__(self) -> float | None:        return currencyIndex(self.currency)    def convertQuantity(self, value: Q_, *, inflationRatio: float = 1.) -> Q_:        if not value.dimensionless:            for dimension, unit in self.units.items():                if value.dimensionality == ureg[unit].dimensionality:                    if '[currency]' in value.dimensionality:                        value = value.to(self.units[dimension], 'conversion')                        value = value * inflationRatio                    else:                        value = value.to(self.units[dimension])        return value    """ Location and time-specific data """    @property    def year(self) -> int:        return self._year    @property    def country(self) -> str:        return self._country    """ System designation """    @property    def type(self):        return self._type    """ Battery technical characteristics (size) """    @property    def nominalDischargeDuration(self) -> Q_ | None:        return self._dischargeDuration    @property    def nominalChargeDuration(self) -> Q_ | None:        return self._chargeDuration    @property    def nominalDischargingPower(self) -> Q_ | None:        return self._dischargingPower    @property    def nominalChargingPower(self) -> Q_ | None:        return self._chargingPower    """ Technical performance """    @property    def nominalRoundTripEfficiency(self) -> Q_ | None:        return self._nominalRoundtripEfficiency    @property    def selfDischargeRate(self) -> Q_ | None:        return self._selfDischargeRate    @property    def secondarySource(self) -> str | None:        return self._secSource    """ Secondary fuel / energy vector """    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        return self._secConsumptionRatio    """ Economic value """    @property    def powerIslandSpecificCost(self) -> Q_ | None:        return self._powerIslandSpecificCost    @property    def storeSpecificCost(self) -> Q_ | None:        return self._storeSpecificCost    """ Economic conditions (scenario- & country-dependent parameters) """    @property    def electricityPrice(self) -> Q_ | None:        return self._electricityPrice    @property    def gasPrice(self) -> Q_ | None:        return self._gasPrice    @property    def hydrogenPrice(self) -> Q_ | None:        return self._hydrogenPrice    @property    def discountRate(self) -> Q_ | None:        return self._discountRate    @property    def wholesaleElectricityPrice(self) -> Q_ | None:        return self.__wholesaleElectricityPrice__    @property    def CEPCI(self) -> float | None:        if self.__CEPCI__ is None:            if self.year in CEPCI.index:                self.__CEPCI__ = float(CEPCI[self.year])            else:                warnings.warn(f'The CEPCI is not available for {self.year}.')        return self.__CEPCI__    """ Utilisation / operational parameters """    @property    def lifetime(self) -> Q_ | None:        return self._lifetime.to('years')    @property    def cyclesPerYear(self) -> int | None:        if self._cyclesPerYear is not None:            return self.maximumCyclesPerYear if self._cyclesPerYear > self.maximumCyclesPerYear else self._cyclesPerYear        else:            return None    """ Dependent properties """    # TODO: redefine secondarySourceInput    @property    def secondarySourceInput(self) -> Q_ | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if not self.secondarySourceConsumptionRatio:            return 0.        else:            r = self.secondarySourceConsumptionRatio            W_out = self.outputElectricity            if None not in [W_out, r]:                return Q_(W_out.magnitude * r, self.units['energy'])            else:                return None    @property    def wholeCycleDuration(self) -> Q_ | None:        if self.__wholeCycleDuration__ is None:            if self.cyclesPerYear is not None:                self.__wholeCycleDuration__ = self.convertQuantity(Q_(1 / self.cyclesPerYear, 'year'))        return self.__wholeCycleDuration__    @property    def standbyDuration(self) -> Q_ | None:        if self.__standbyDuration__ is None:            dt = self.wholeCycleDuration            dt_w = self.workingCycleDuration            dt_norm_stb = self._standby            if None not in [dt, dt_w, dt_norm_stb]:                dt_idle = dt.magnitude - dt_w.magnitude                self.__standbyDuration__ = Q_(dt_norm_stb * dt_idle, self.units['time'])        return self.__standbyDuration__    @property    def workingCycleDuration(self) -> Q_ | None:        if self.__workingCycleDuration__ is None:            dt_discharge = self.nominalDischargeDuration            dt_charge = self.nominalChargeDuration            if None not in [dt_discharge, dt_charge]:                self.__workingCycleDuration__ = Q_(dt_discharge.magnitude + dt_charge.magnitude, self.units['time'])        return self.__workingCycleDuration__    @property    def storageCapacity(self) -> Q_ | None:        if self.__storageCapacity__ is None:            # Gather inputs parameters            dt = self.nominalDischargeDuration            W = self.nominalDischargingPower            if None not in [W, dt]:                self.__storageCapacity__ = Q_(W.magnitude * dt.magnitude, self.units['energy'])        return self.__storageCapacity__    @property    def investmentCost(self) -> Q_ | None:        if self.__investmentCost__ is None:            powerCost = self.powerIslandSpecificCost            energyCost = self.storeSpecificCost            W = self.nominalDischargingPower            E = self.storageCapacity            if None not in [E, W] and powerCost is not None and energyCost is not None:                powerCost = powerCost.magnitude                energyCost = energyCost.magnitude                W = W.magnitude                E = E.magnitude                if isinstance(powerCost, Iterable) and isinstance(energyCost, Iterable):                    self.__investmentCost__ = [float(W * pc + E * ec) for pc, ec in zip(powerCost, energyCost)]                elif isinstance(powerCost, Iterable):                    self.__investmentCost__ = [float(W * pc + E * energyCost) for pc in powerCost]                elif isinstance(energyCost, Iterable):                    self.__investmentCost__ = [float(W * powerCost + E * ec) for ec in energyCost]                else:                    self.__investmentCost__ = float(W * powerCost + E * energyCost)                # Apply unit                self.__investmentCost__ = self.__investmentCost__ * ureg[self.units['currency']]        return self.__investmentCost__    @property    def maximumCyclesPerYear(self) -> Q_ | None:        if self.__maximumCyclesPerYear__ is None:            if self.workingCycleDuration is not None:                cycleDuration = self.workingCycleDuration.to('year')                self.__maximumCyclesPerYear__ = int(1 / cycleDuration.magnitude)        return self.__maximumCyclesPerYear__    @property    def inputElectricity(self) -> Q_ | None:        if self.__inputElectricity__ is None:            # Gather inputs parameters            dt = self.nominalChargeDuration            W = self.nominalChargingPower            if None not in [W, dt]:                self.__inputElectricity__ = Q_(W.magnitude * dt.magnitude, self.units['energy'])        return self.__inputElectricity__    @property    def outputElectricity(self) -> Q_ | None:        if self.__outputElectricity__ is None:            # Gather inputs parameters            W_in = self.inputElectricity            dWdt = self.selfDischargeRate            dt_stb = self.standbyDuration            eta = self.nominalRoundTripEfficiency            if None not in [W_in, dWdt, dt_stb, eta]:                # Collect and rescale magnitudes                W_in = W_in.magnitude                dWdt = dWdt.to('1/hour').magnitude                dt_stb = dt_stb.magnitude                eta = eta.to('').magnitude                # Output electricity                W_st = W_in * (1 - dWdt) ** dt_stb                self.__outputElectricity__ = Q_(eta * W_st if W_st > 0 else 0, self.units['energy'])        return self.__outputElectricity__    @property    def roundtripEfficiency(self):        if self.__roundtripEfficiency__ is None:            W_in = self.inputElectricity            W_out = self.outputElectricity            if None not in [W_in, W_out]:                self.__roundtripEfficiency__ = Q_(W_out.magnitude / W_in.magnitude, self.units['efficiency'])        return self.__roundtripEfficiency__    @property    def levelisedCostOfStorage(self) -> Q_ | None:        if self.__LCOS__ is None:            # Gather inputs parameters            investmentCost = self.investmentCost            W_in_MWh = self.inputElectricity            W_out_MWh = self.outputElectricity            i = self.discountRate            n = self.lifetime            f = self.cyclesPerYear            C_el = self.electricityPrice  # $/MWh            Q_sec_Mwh = self.secondarySourceInput            C_sec = Q_(0, self.units['energySpecificCost']) if not self.secondarySource \                else self.gasPrice if self.secondarySource == 'gas' \                else self.hydrogenPrice if self.secondarySource == 'hydrogen' \                else None            if investmentCost is not None and None not in [i, n, W_in_MWh, W_out_MWh, f, Q_sec_Mwh, C_el, C_sec]:                # Collect and rescale magnitudes                investmentCost = investmentCost.magnitude                W_in_MWh = W_in_MWh.magnitude                W_out_MWh = W_out_MWh.magnitude                i = i.to('').magnitude                n = int(n.magnitude)                C_el = C_el.magnitude  # $/MWh                Q_sec_Mwh = Q_sec_Mwh.magnitude                C_sec = C_sec.magnitude                n = np.arange(1, n)                discount = (1 + i) ** n                # Upfront costs                C_inv = investmentCost                # Discounted operational costs                yearlyConsumption = W_in_MWh * C_el * f + Q_sec_Mwh * C_sec * f                C_op = (yearlyConsumption / discount).sum()                # Discounted electricity recovered                yearlyDischarge = W_out_MWh * f                W_kWh = (yearlyDischarge / discount).sum()                self.__LCOS__ = (C_inv + C_op) / W_kWh  # [$/kWh]                if isinstance(self.__LCOS__, Iterable):                    self.__LCOS__ = [float(x) for x in self.__LCOS__]                # Apply unit                self.__LCOS__ = Q_(self.__LCOS__, 'USD/kWh')        return self.__LCOS__""" SYSTEMS """class ElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()    def factory(self) -> ElectricityStorageTechnology:        return ElectricityStorageTechnology()    def withInputs(self, *,                   dischargeDuration: Q_ | None = None,  # nominal discharge duration [s]                   dischargingPower: Q_ | None = None,  # nominal discharging power [W]                   chargeDuration: Q_ | None = None,  # nominal charge duration [s]                   chargingPower: Q_ | None = None,  # nominal charging power [W]                   roundtripEfficiency: Q_ | None = None,  # (instantaneous) roundtrip efficiency (x > 0)                   powerIslandSpecificCost: Q_ | None = None,  # cost power island [$/kW]                   storeSpecificCost: Q_ | None = None,  # energy-specific cost of the store [$/kWh]                   selfDischargeRate: Q_ | None = None,  # self-discharge rate [%/h]                   secondarySource: str | None = None,  # secondary fuel used upon discharge (optional)                   secondaryConsumptionRatio: Q_ | None = None,  # upon discharge [kWh_g / kWh_e]                   discountRate: Q_ | None = None,                   cyclesPerYear: int | None = None,                   lifetime: Q_ | None = None,                   standby: Q_ | None = None) -> ElectricityStorageTechnology:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            roundtripEfficiency=roundtripEfficiency,            powerIslandSpecificCost=powerIslandSpecificCost,            storeSpecificCost=storeSpecificCost,            selfDischargeRate=selfDischargeRate,            secondarySource=secondarySource,            secondaryConsumptionRatio=secondaryConsumptionRatio,            cyclesPerYear=cyclesPerYear,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return objclass DataDrivenElectricityStorageTechnology(_AbstractElectricityStorageTechnology):    """ Data stored in pystorage/data folder as csv files with the following fields and second header indicating unit:    duration, power,    roundtripEfficiency, secondaryConsumptionRatio,    powerIslandSpecificCost_LB, powerIslandSpecificCost, powerIslandSpecificCost_UB,    storeSpecificCost_LB, storeSpecificCost, storeSpecificCost_UB    Ex:    h,MW,%,W/W,USD/kW,USD/kW,USD/kW,USD/kWh,USD/kWh,USD/kWh    4, 100, 74.6, 1.189, 945.25, 1050.28, 1155.3, 2.76, 9.99, 16.59    """    def __init__(self):        super().__init__()        # Collected data        self._data = None        self._type: str | None = None        self._model: str | None = None        # Scattered interpolation for predicting techno-economic value        LND = LinearNDInterpolator([[0, 0], [1, 0], [0, 1], [1, 1]], [0, 1, 2, 4])        self.scatteredInterpolation = {            'roundtripEfficiency': LND,            'secondaryConsumptionRatio': LND,            'powerIslandSpecificCost': LND,            'storeSpecificCost': LND,            'powerIslandSpecificCost_LB': LND,            'storeSpecificCost_LB': LND,            'powerIslandSpecificCost_UB': LND,            'storeSpecificCost_UB': LND,        }        # # Scattered interpolation for technical performance        # self._roundtripEfficiency_int: LinearNDInterpolator | None = None  # e-to-e ratio [W_out / W_in]        # self._secConsumptionRatio_int: LinearNDInterpolator | None = None  # consumption ratio [kWh_g / kWh_e]        #        # # Scattered interpolation for power island SIC        # self._powerIslandSIC_int: LinearNDInterpolator | None = None        # self._powerIslandSIC_LB_int: LinearNDInterpolator | None = None        # self._powerIslandSIC_UB_int: LinearNDInterpolator | None = None        #        # # Scattered interpolation for store SIC        # self._storeSIC_int: LinearNDInterpolator | None = None        # self._storeSIC_LB_int: LinearNDInterpolator | None = None        # self._storeSIC_UB_int: LinearNDInterpolator | None = None    """ Factory & reset methods """    def factory(self) -> DataDrivenElectricityStorageTechnology:        return DataDrivenElectricityStorageTechnology()    def _resetGhostProperties(self):        super()._resetGhostProperties()        # Design-dependent private properties        self._nominalRoundtripEfficiency = None        self._secConsumptionRatio = None        self._powerIslandSpecificCost = None        self._storeSpecificCost = None    """ Assign static & dynamic methods """    @staticmethod    def _assignData(obj: DataDrivenElectricityStorageTechnology, data: dict, year: int):        # Store data        obj._data = copy.deepcopy(data)        # Inflation        inflationRatio = obj.CEPCI / CEPCI[year]        # Convert data        for key, values in obj._data.items():            newValues = obj.convertQuantity(value=values, inflationRatio=inflationRatio)            obj._data[key] = newValues.magnitude        # Create linear N-D interpolation methods        for key, values in obj._data.items():            if key in obj.scatteredInterpolation.keys():                obj.scatteredInterpolation[key] = LinearNDInterpolator(                    points=list(zip(obj._data['duration'], obj._data['power'])), values=values)        return obj    def withInputs(self, dataSource: str,                   *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   dischargingPower: float | None = None,  # nominal discharging power [W]                   chargeDuration: float | None = None,  # nominal charge duration [s]                   chargingPower: float | None = None,  # nominal charging power [W]                   selfDischargeRate: float | None = None,  # self-discharge rate [%/h]                   discountRate: float | None = None,                   cyclesPerYear: int | None = None,                   lifetime: int | None = None,                   standby: float | None = None) -> DataDrivenElectricityStorageTechnology:        obj = self.factory()        if dataSource == 'PNNL_CAES':            obj._type = 'D-CAES'            obj._model = 'PNNL'            obj._secSource = 'gas'            obj._assignData(obj, data=PNNL_CAES, year=2023)        else:            raise ValueError(f'No data available for {dataSource}')        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=dischargingPower,            chargeDuration=chargeDuration,            chargingPower=chargingPower,            selfDischargeRate=selfDischargeRate,            cyclesPerYear=cyclesPerYear,            lifetime=lifetime,            discountRate=discountRate,            standby=standby)        return obj    """ Update methods """    def updateDataSource(self, dataSource: str):        self._resetGhostProperties()        if dataSource == 'PNNL_CAES':            self._type = 'D-CAES'            self._model = 'PNNL'            self._secSource = 'gas'            self._assignData(self, data=PNNL_CAES, year=2023)        else:            raise ValueError(f'No data available for {dataSource}')    def updateDesign(self, *,                     dischargeDuration: float | None = None,  # nominal discharge duration [s]                     dischargingPower: float | None = None,  # nominal discharging power [W]                     chargeDuration: float | None = None,  # nominal charge duration [s]                     chargingPower: float | None = None,  # nominal charging power [W]                     selfDischargeRate: float = 0,  # self-discharge rate [%/h]                     lifetime: int | None = None                     ):        # Reset ghost properties        self._resetGhostProperties()        self._assign(obj=self,                     dischargeDuration=dischargeDuration,                     dischargingPower=dischargingPower,                     chargeDuration=chargeDuration,                     chargingPower=chargingPower,                     selfDischargeRate=selfDischargeRate,                     lifetime=lifetime)    """ Dependent properties """    @property    def model(self) -> str:        return self._model    @property    def nominalRoundTripEfficiency(self) -> float | None:        if self._nominalRoundtripEfficiency is None:            duration = self.nominalDischargeDuration            power = self.nominalDischargingPower            if None not in [duration, power]:                function = self.scatteredInterpolation['roundtripEfficiency']                value = function(duration.magnitude, power.magnitude)                self._nominalRoundtripEfficiency = float(value) * ureg[self.units['efficiency']]        return self._nominalRoundtripEfficiency    @property    def secondarySourceConsumptionRatio(self) -> float | None:  # Q_sec / W_out [kWh_sec / kWh_e]        if self._secConsumptionRatio is None:            duration = self.nominalDischargeDuration            power = self.nominalDischargingPower            if None not in [duration, power]:                function = self.scatteredInterpolation['secondaryConsumptionRatio']                value = function(duration.magnitude, power.magnitude)                self._secConsumptionRatio = float(value)        return self._secConsumptionRatio    @property    def powerIslandSpecificCost(self) -> Q_ | None:        if self._powerIslandSpecificCost is None:            duration = self.nominalDischargeDuration            power = self.nominalDischargingPower            if None not in [duration, power]:                # Lower bound                function = self.scatteredInterpolation['powerIslandSpecificCost_LB']                value = function(duration.magnitude, power.magnitude)                self._powerIslandSpecificCost = [float(value)]                # Mean value                function = self.scatteredInterpolation['powerIslandSpecificCost']                value = function(duration.magnitude, power.magnitude)                self._powerIslandSpecificCost.append(float(value))                # Upper bound                function = self.scatteredInterpolation['powerIslandSpecificCost_UB']                value = function(duration.magnitude, power.magnitude)                self._powerIslandSpecificCost.append(float(value))                # Apply unit                self._powerIslandSpecificCost = self._powerIslandSpecificCost * ureg[self.units['powerSpecificCost']]        return self._powerIslandSpecificCost    @property    def storeSpecificCost(self) -> Q_ | None:        if self._storeSpecificCost is None:            duration = self.nominalDischargeDuration            power = self.nominalDischargingPower            if None not in [duration, power]:                # Lower bound                function = self.scatteredInterpolation['storeSpecificCost_LB']                value = function(duration.magnitude, power.magnitude)                self._storeSpecificCost = [float(value)]                # Mean value                function = self.scatteredInterpolation['storeSpecificCost']                value = function(duration.magnitude, power.magnitude)                self._storeSpecificCost.append(float(value))                # Upper bound                function = self.scatteredInterpolation['storeSpecificCost_UB']                value = function(duration.magnitude, power.magnitude)                self._storeSpecificCost.append(float(value))                # Apply unit                self._storeSpecificCost = self._storeSpecificCost * ureg[self.units['energySpecificCost']]        return self._storeSpecificCostclass DiabaticCAES(_AbstractElectricityStorageTechnology):    def __init__(self):        super().__init__()        self._type = 'D-CAES'        self._model = 'firstLaw'    def factory(self) -> DiabaticCAES:        return DiabaticCAES()    def withDesign(self, *,                   dischargeDuration: float | None = None,  # nominal discharge duration [s]                   power: float | None = None,  # nominal discharging power [W]                   selfDischargeRate: float = 0  # self-discharge rate [%/h]                   ) -> DiabaticCAES:        obj = self.factory()        # Assign input parameters        obj._assign(            obj,            dischargeDuration=dischargeDuration,            dischargingPower=power,            chargingPower=power,            selfDischargeRate=selfDischargeRate,            roundtripEfficiency=self._nominalRoundtripEfficiency,            secondarySource=self._secSource,            secondaryConsumptionRatio=self._secConsumptionRatio)        return obj    @property    def model(self) -> str:        return self._model